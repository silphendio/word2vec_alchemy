<!DOCTYPE html>
<html lang="de">
  <head>
    <title>Word2Vec Alchemy</title>
    <meta charset="utf-8" />
    <meta name="color-scheme" content="dark light" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://unpkg.com/mathjs@12.3.1/lib/browser/math.js"></script>
  </head>

  <body>
    <h1>Word2Vec Alchemy</h1>
    <p id="loading_text">loading...</p>
    <div id="words_div">
    </div>
    <br>
    <div><button onclick="click_merge()">merge!</button></div>
    <br>
    <form action="javascript:add_word_from_input()">
      <input type="text" id="new_word_input">
      <input type="submit" value="add new word">
      (if available)
    </form>
    <br><hr>
    <h2>Word2Vec Arithmetic</h2>
    <form action="javascript:process_word_math_input()">
      <input type="text" id="word_math_input" placeholder="king + (woman - man) * 2">
      <input type="submit" value="calculate">
    </form>
    <span id="error_span"></span>
    <br>
    <a href="https://www.desiquintans.com/nounlist">dictionary is limited to common nouns</a><br>
    Closest words are calculated using Cosine Similarity, so scaling doesn't matter.
    <h3>Results:</h3>
    <table id="results_table"></table>
    <br><hr><br>
    <div>
      <a href="https://github.com/silphendio/word2vec_alchemy">Github Repository</a><br>
      word embeddings from <a href="https://nlp.stanford.edu/projects/glove/">GloVe</a><br>
      filtered to <a href="https://www.desiquintans.com/nounlist">The Great Noun List </a><br>
      powered by <a href="https://mathjs.org">math.js</a>
    </div>

    <script>
// helper functions
function $(query){ return document.querySelector(query) }
function el(name, attributes = {}, children = []){
  let el = document.createElement(name)
  for(let a in attributes){
  el.setAttribute(a, attributes[a])
  }
  el.append(...children)
  return el
}

// variables
const current_selection = new Set()
var embeddings = null

fetch("noun_embeddings.json")
  .then(res => res.json())
  .then(res => {
    embeddings = res
    for (let [word, embd] of Object.entries(embeddings)){
      // this is really slow in math.js, and we're only interested in the angle between words
      embeddings[word] = math.divide(embd, math.norm(embd))
    }
    $('#loading_text').hidden=true
  })

//fetch("noun_embeddings.json").then(res => res.json()).then(res => embeddings = res)
const found_words = new Set()

// starting words
add_word("fire")
add_word("water")
add_word("wind")
add_word("stone")


function toggle_highlight(e){ 
  e.classList.toggle("highlight")
  if(!current_selection.has(e.id)){
    console.log("added", e.id)
    current_selection.add(e.id)
  }
  else { current_selection.delete(e.id) ;console.log("removed", e.id)}
}

function remove_highlights(){
  for(word of current_selection){
    $('#' + word).classList.remove("highlight")
  }
  current_selection.clear()
}

function add_word_from_input(){
  const word_input = $('#new_word_input')
  const word = word_input.value.toLowerCase()
  if(word in embeddings){
    add_word(word)
  }
  word_input.value = ""
}

function add_word(word){
  if(found_words.has(word)) return
  found_words.add(word)

  const words_div = $('#words_div')
  const button = el("button", {id: word}, word)
  button.addEventListener("click", (e) => toggle_highlight(e.target))
  words_div.appendChild(button)
}

function click_merge(){
  let closest_word = merge_words(current_selection)

  if(!found_words.has(closest_word)){
    add_word(closest_word)
  }

  remove_highlights()
  toggle_highlight($('#'+closest_word))
}

function merge_words(words){
  if(!embeddings) return // not yet ready

  // get arithmetic mean of word embeddings
  const merged_embedding = new Array(embeddings["word"].length).fill(0)
  for(let word of words){
    let embedding = embeddings[word]
    for(let i=0; i<embedding.length; ++i){
      merged_embedding[i] += embedding[i] / words.size
    }
  }

  return find_topk_words(merged_embedding, 1, words)[0].word
}

function process_word_math_input(num_results = 10){
  $('#error_span').hidden = true
  $('#results_table').innerHTML = ""

  let expr = $('#word_math_input').value

  // replace words with vectors
  while(true){
    let match = expr.match(/[a-zA-Z]+/)
    if(match === null) break

    let word = match[0].toLocaleLowerCase()

    if(!(word in embeddings)){
      $('#error_span').hidden = false
      $('#error_span').textContent = "Error: '" + word + "' is not in dictionary"
      return
    }
    expr = expr.replace(match[0], JSON.stringify(embeddings[word]))
  }

  // calculate result
  try{
    result = math.evaluate(expr).toArray()
  }
  catch(error){
    $('#error_span').hidden = false
    $('#error_span').textContent = error
    return
  }
  matches = find_topk_words(result, num_results)

  // add matches into results_table
  let results_table = $('#results_table')

  for(let i=0; i<num_results; ++i){
    results_table.append(el('tr', {}, [
      el('td', {}, matches[i].word),
      el('td', {}, String(matches[i].similarity)),
    ]))
  }
}

function find_topk_words(word_vec, num_results = 1, exclude_words = new Set()){
  word_vec = math.squeeze(word_vec)
  word_vec = math.divide(word_vec, math.norm(word_vec))
  
  let matches = new Array(num_results).fill({word: "", similarity: -Infinity})

  for (let [word, embd] of Object.entries(embeddings)){

    if(exclude_words.has(word)) continue

    let s = math.dot(word_vec, embd)

    let i = num_results
    while(i > 0 && s > matches[i-1].similarity) i -= 1
    if(i < num_results){
      matches.splice(i, 0, {word: word, similarity: s})
    }
  }
  return matches
}

    </script>
    <style>
.highlight {
  background-color:darkorange;
}
table, th, td {
  border:1px solid;
}
#error_span {
  color:red;
}

    </style>
  </body>
</html>